{"version":3,"file":"instrumentation.js","sources":["../../../../../src/integrations/tracing/vercelai/instrumentation.ts"],"sourcesContent":["import type { InstrumentationConfig, InstrumentationModuleDefinition } from '@opentelemetry/instrumentation';\nimport { InstrumentationBase, InstrumentationNodeModuleDefinition } from '@opentelemetry/instrumentation';\nimport {\n  addNonEnumerableProperty,\n  getActiveSpan,\n  getCurrentScope,\n  handleCallbackErrors,\n  SDK_VERSION,\n} from '@sentry/core';\nimport { INTEGRATION_NAME } from './constants';\nimport type { TelemetrySettings, VercelAiIntegration } from './types';\n\n// List of patched methods\n// From: https://sdk.vercel.ai/docs/ai-sdk-core/telemetry#collected-data\nconst INSTRUMENTED_METHODS = [\n  'generateText',\n  'streamText',\n  'generateObject',\n  'streamObject',\n  'embed',\n  'embedMany',\n] as const;\n\ninterface MethodFirstArg extends Record<string, unknown> {\n  experimental_telemetry?: TelemetrySettings;\n}\n\ntype MethodArgs = [MethodFirstArg, ...unknown[]];\n\ntype PatchedModuleExports = Record<(typeof INSTRUMENTED_METHODS)[number], (...args: MethodArgs) => unknown> &\n  Record<string, unknown>;\n\ninterface RecordingOptions {\n  recordInputs?: boolean;\n  recordOutputs?: boolean;\n}\n\n/**\n * Determines whether to record inputs and outputs for Vercel AI telemetry based on the configuration hierarchy.\n *\n * The order of precedence is:\n * 1. The vercel ai integration options\n * 2. The experimental_telemetry options in the vercel ai method calls\n * 3. When telemetry is explicitly enabled (isEnabled: true), default to recording\n * 4. Otherwise, use the sendDefaultPii option from client options\n */\nexport function determineRecordingSettings(\n  integrationRecordingOptions: RecordingOptions | undefined,\n  methodTelemetryOptions: RecordingOptions,\n  telemetryExplicitlyEnabled: boolean | undefined,\n  defaultRecordingEnabled: boolean,\n): { recordInputs: boolean; recordOutputs: boolean } {\n  const recordInputs =\n    integrationRecordingOptions?.recordInputs !== undefined\n      ? integrationRecordingOptions.recordInputs\n      : methodTelemetryOptions.recordInputs !== undefined\n        ? methodTelemetryOptions.recordInputs\n        : telemetryExplicitlyEnabled === true\n          ? true // When telemetry is explicitly enabled, default to recording inputs\n          : defaultRecordingEnabled;\n\n  const recordOutputs =\n    integrationRecordingOptions?.recordOutputs !== undefined\n      ? integrationRecordingOptions.recordOutputs\n      : methodTelemetryOptions.recordOutputs !== undefined\n        ? methodTelemetryOptions.recordOutputs\n        : telemetryExplicitlyEnabled === true\n          ? true // When telemetry is explicitly enabled, default to recording inputs\n          : defaultRecordingEnabled;\n\n  return { recordInputs, recordOutputs };\n}\n\n/**\n * This detects is added by the Sentry Vercel AI Integration to detect if the integration should\n * be enabled.\n *\n * It also patches the `ai` module to enable Vercel AI telemetry automatically for all methods.\n */\nexport class SentryVercelAiInstrumentation extends InstrumentationBase {\n  private _isPatched = false;\n  private _callbacks: (() => void)[] = [];\n\n  public constructor(config: InstrumentationConfig = {}) {\n    super('@sentry/instrumentation-vercel-ai', SDK_VERSION, config);\n  }\n\n  /**\n   * Initializes the instrumentation by defining the modules to be patched.\n   */\n  public init(): InstrumentationModuleDefinition {\n    const module = new InstrumentationNodeModuleDefinition('ai', ['>=3.0.0 <5'], this._patch.bind(this));\n    return module;\n  }\n\n  /**\n   * Call the provided callback when the module is patched.\n   * If it has already been patched, the callback will be called immediately.\n   */\n  public callWhenPatched(callback: () => void): void {\n    if (this._isPatched) {\n      callback();\n    } else {\n      this._callbacks.push(callback);\n    }\n  }\n\n  /**\n   * Patches module exports to enable Vercel AI telemetry.\n   */\n  private _patch(moduleExports: PatchedModuleExports): unknown {\n    this._isPatched = true;\n\n    this._callbacks.forEach(callback => callback());\n    this._callbacks = [];\n\n    function generatePatch(originalMethod: (...args: MethodArgs) => unknown) {\n      return (...args: MethodArgs) => {\n        const existingExperimentalTelemetry = args[0].experimental_telemetry || {};\n        const isEnabled = existingExperimentalTelemetry.isEnabled;\n\n        const client = getCurrentScope().getClient();\n        const integration = client?.getIntegrationByName<VercelAiIntegration>(INTEGRATION_NAME);\n        const integrationOptions = integration?.options;\n        const shouldRecordInputsAndOutputs = integration ? Boolean(client?.getOptions().sendDefaultPii) : false;\n\n        const { recordInputs, recordOutputs } = determineRecordingSettings(\n          integrationOptions,\n          existingExperimentalTelemetry,\n          isEnabled,\n          shouldRecordInputsAndOutputs,\n        );\n\n        args[0].experimental_telemetry = {\n          ...existingExperimentalTelemetry,\n          isEnabled: isEnabled !== undefined ? isEnabled : true,\n          recordInputs,\n          recordOutputs,\n        };\n\n        return handleCallbackErrors(\n          () => {\n            // @ts-expect-error we know that the method exists\n            return originalMethod.apply(this, args);\n          },\n          error => {\n            // This error bubbles up to unhandledrejection handler (if not handled before),\n            // where we do not know the active span anymore\n            // So to circumvent this, we set the active span on the error object\n            // which is picked up by the unhandledrejection handler\n            if (error && typeof error === 'object') {\n              addNonEnumerableProperty(error, '_sentry_active_span', getActiveSpan());\n            }\n          },\n        );\n      };\n    }\n\n    // Is this an ESM module?\n    // https://tc39.es/ecma262/#sec-module-namespace-objects\n    if (Object.prototype.toString.call(moduleExports) === '[object Module]') {\n      // In ESM we take the usual route and just replace the exports we want to instrument\n      for (const method of INSTRUMENTED_METHODS) {\n        moduleExports[method] = generatePatch(moduleExports[method]);\n      }\n\n      return moduleExports;\n    } else {\n      // In CJS we can't replace the exports in the original module because they\n      // don't have setters, so we create a new object with the same properties\n      const patchedModuleExports = INSTRUMENTED_METHODS.reduce((acc, curr) => {\n        acc[curr] = generatePatch(moduleExports[curr]);\n        return acc;\n      }, {} as PatchedModuleExports);\n\n      return { ...moduleExports, ...patchedModuleExports };\n    }\n  }\n}\n"],"names":[],"mappings":"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"}