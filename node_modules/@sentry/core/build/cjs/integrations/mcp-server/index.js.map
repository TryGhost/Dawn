{"version":3,"file":"index.js","sources":["../../../../src/integrations/mcp-server/index.ts"],"sourcesContent":["import { fill } from '../../utils/object';\nimport { wrapAllMCPHandlers } from './handlers';\nimport { wrapTransportError, wrapTransportOnClose, wrapTransportOnMessage, wrapTransportSend } from './transport';\nimport type { MCPServerInstance, MCPTransport } from './types';\nimport { validateMcpServerInstance } from './validation';\n\n/**\n * Tracks wrapped MCP server instances to prevent double-wrapping\n * @internal\n */\nconst wrappedMcpServerInstances = new WeakSet();\n\n/**\n * Wraps a MCP Server instance from the `@modelcontextprotocol/sdk` package with Sentry instrumentation.\n *\n * Compatible with versions `^1.9.0` of the `@modelcontextprotocol/sdk` package.\n * Automatically instruments transport methods and handler functions for comprehensive monitoring.\n *\n * @example\n * ```typescript\n * import * as Sentry from '@sentry/core';\n * import { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js';\n * import { StreamableHTTPServerTransport } from '@modelcontextprotocol/sdk/server/streamableHttp.js';\n *\n * const server = Sentry.wrapMcpServerWithSentry(\n *   new McpServer({ name: \"my-server\", version: \"1.0.0\" })\n * );\n *\n * const transport = new StreamableHTTPServerTransport();\n * await server.connect(transport);\n * ```\n *\n * @param mcpServerInstance - MCP server instance to instrument\n * @returns Instrumented server instance (same reference)\n */\nexport function wrapMcpServerWithSentry<S extends object>(mcpServerInstance: S): S {\n  if (wrappedMcpServerInstances.has(mcpServerInstance)) {\n    return mcpServerInstance;\n  }\n\n  if (!validateMcpServerInstance(mcpServerInstance)) {\n    return mcpServerInstance;\n  }\n\n  const serverInstance = mcpServerInstance as MCPServerInstance;\n\n  fill(serverInstance, 'connect', originalConnect => {\n    return async function (this: MCPServerInstance, transport: MCPTransport, ...restArgs: unknown[]) {\n      const result = await (originalConnect as (...args: unknown[]) => Promise<unknown>).call(\n        this,\n        transport,\n        ...restArgs,\n      );\n\n      wrapTransportOnMessage(transport);\n      wrapTransportSend(transport);\n      wrapTransportOnClose(transport);\n      wrapTransportError(transport);\n\n      return result;\n    };\n  });\n\n  wrapAllMCPHandlers(serverInstance);\n\n  wrappedMcpServerInstances.add(mcpServerInstance);\n  return mcpServerInstance as S;\n}\n"],"names":["validateMcpServerInstance","fill","transport","wrapTransportOnMessage","wrapTransportSend","wrapTransportOnClose","wrapTransportError","wrapAllMCPHandlers"],"mappings":";;;;;;;AAMA;AACA;AACA;AACA;AACA,MAAM,yBAAA,GAA4B,IAAI,OAAO,EAAE;;AAE/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAAS,uBAAuB,CAAmB,iBAAiB,EAAQ;AACnF,EAAE,IAAI,yBAAyB,CAAC,GAAG,CAAC,iBAAiB,CAAC,EAAE;AACxD,IAAI,OAAO,iBAAiB;AAC5B;;AAEA,EAAE,IAAI,CAACA,oCAAyB,CAAC,iBAAiB,CAAC,EAAE;AACrD,IAAI,OAAO,iBAAiB;AAC5B;;AAEA,EAAE,MAAM,cAAA,GAAiB,iBAAA;;AAEzB,EAAEC,WAAI,CAAC,cAAc,EAAE,SAAS,EAAE,mBAAmB;AACrD,IAAI,OAAO,iBAAyCC,WAAS,EAAgB,GAAG,QAAQ,EAAa;AACrG,MAAM,MAAM,SAAS,MAAM,CAAC,eAAA,GAA6D,IAAI;AAC7F,QAAQ,IAAI;AACZ,QAAQA,WAAS;AACjB,QAAQ,GAAG,QAAQ;AACnB,OAAO;;AAEP,MAAMC,gCAAsB,CAACD,WAAS,CAAC;AACvC,MAAME,2BAAiB,CAACF,WAAS,CAAC;AAClC,MAAMG,8BAAoB,CAACH,WAAS,CAAC;AACrC,MAAMI,4BAAkB,CAACJ,WAAS,CAAC;;AAEnC,MAAM,OAAO,MAAM;AACnB,KAAK;AACL,GAAG,CAAC;;AAEJ,EAAEK,2BAAkB,CAAC,cAAc,CAAC;;AAEpC,EAAE,yBAAyB,CAAC,GAAG,CAAC,iBAAiB,CAAC;AAClD,EAAE,OAAO,iBAAA;AACT;;;;"}