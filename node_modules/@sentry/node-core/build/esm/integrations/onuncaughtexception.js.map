{"version":3,"file":"onuncaughtexception.js","sources":["../../../src/integrations/onuncaughtexception.ts"],"sourcesContent":["import { captureException, debug, defineIntegration, getClient } from '@sentry/core';\nimport { DEBUG_BUILD } from '../debug-build';\nimport type { NodeClient } from '../sdk/client';\nimport { logAndExitProcess } from '../utils/errorhandling';\n\ntype OnFatalErrorHandler = (firstError: Error, secondError?: Error) => void;\n\ntype TaggedListener = NodeJS.UncaughtExceptionListener & {\n  tag?: string;\n};\n\ninterface OnUncaughtExceptionOptions {\n  /**\n   * Controls if the SDK should register a handler to exit the process on uncaught errors:\n   * - `true`: The SDK will exit the process on all uncaught errors.\n   * - `false`: The SDK will only exit the process when there are no other `uncaughtException` handlers attached.\n   *\n   * Default: `false`\n   */\n  exitEvenIfOtherHandlersAreRegistered: boolean;\n\n  /**\n   * This is called when an uncaught error would cause the process to exit.\n   *\n   * @param firstError Uncaught error causing the process to exit\n   * @param secondError Will be set if the handler was called multiple times. This can happen either because\n   * `onFatalError` itself threw, or because an independent error happened somewhere else while `onFatalError`\n   * was running.\n   */\n  onFatalError?(this: void, firstError: Error, secondError?: Error): void;\n}\n\nconst INTEGRATION_NAME = 'OnUncaughtException';\n\n/**\n * Add a global exception handler.\n */\nexport const onUncaughtExceptionIntegration = defineIntegration((options: Partial<OnUncaughtExceptionOptions> = {}) => {\n  const optionsWithDefaults = {\n    exitEvenIfOtherHandlersAreRegistered: false,\n    ...options,\n  };\n\n  return {\n    name: INTEGRATION_NAME,\n    setup(client: NodeClient) {\n      global.process.on('uncaughtException', makeErrorHandler(client, optionsWithDefaults));\n    },\n  };\n});\n\ntype ErrorHandler = { _errorHandler: boolean } & ((error: Error) => void);\n\n/** Exported only for tests */\nexport function makeErrorHandler(client: NodeClient, options: OnUncaughtExceptionOptions): ErrorHandler {\n  const timeout = 2000;\n  let caughtFirstError: boolean = false;\n  let caughtSecondError: boolean = false;\n  let calledFatalError: boolean = false;\n  let firstError: Error;\n\n  const clientOptions = client.getOptions();\n\n  return Object.assign(\n    (error: Error): void => {\n      let onFatalError: OnFatalErrorHandler = logAndExitProcess;\n\n      if (options.onFatalError) {\n        onFatalError = options.onFatalError;\n      } else if (clientOptions.onFatalError) {\n        onFatalError = clientOptions.onFatalError as OnFatalErrorHandler;\n      }\n\n      // Attaching a listener to `uncaughtException` will prevent the node process from exiting. We generally do not\n      // want to alter this behaviour so we check for other listeners that users may have attached themselves and adjust\n      // exit behaviour of the SDK accordingly:\n      // - If other listeners are attached, do not exit.\n      // - If the only listener attached is ours, exit.\n      const userProvidedListenersCount = (global.process.listeners('uncaughtException') as TaggedListener[]).filter(\n        listener => {\n          // There are 3 listeners we ignore:\n          return (\n            // as soon as we're using domains this listener is attached by node itself\n            listener.name !== 'domainUncaughtExceptionClear' &&\n            // the handler we register for tracing\n            listener.tag !== 'sentry_tracingErrorCallback' &&\n            // the handler we register in this integration\n            (listener as ErrorHandler)._errorHandler !== true\n          );\n        },\n      ).length;\n\n      const processWouldExit = userProvidedListenersCount === 0;\n      const shouldApplyFatalHandlingLogic = options.exitEvenIfOtherHandlersAreRegistered || processWouldExit;\n\n      if (!caughtFirstError) {\n        // this is the first uncaught error and the ultimate reason for shutting down\n        // we want to do absolutely everything possible to ensure it gets captured\n        // also we want to make sure we don't go recursion crazy if more errors happen after this one\n        firstError = error;\n        caughtFirstError = true;\n\n        if (getClient() === client) {\n          captureException(error, {\n            originalException: error,\n            captureContext: {\n              level: 'fatal',\n            },\n            mechanism: {\n              handled: false,\n              type: 'onuncaughtexception',\n            },\n          });\n        }\n\n        if (!calledFatalError && shouldApplyFatalHandlingLogic) {\n          calledFatalError = true;\n          onFatalError(error);\n        }\n      } else {\n        if (shouldApplyFatalHandlingLogic) {\n          if (calledFatalError) {\n            // we hit an error *after* calling onFatalError - pretty boned at this point, just shut it down\n            DEBUG_BUILD &&\n              debug.warn(\n                'uncaught exception after calling fatal error shutdown callback - this is bad! forcing shutdown',\n              );\n            logAndExitProcess(error);\n          } else if (!caughtSecondError) {\n            // two cases for how we can hit this branch:\n            //   - capturing of first error blew up and we just caught the exception from that\n            //     - quit trying to capture, proceed with shutdown\n            //   - a second independent error happened while waiting for first error to capture\n            //     - want to avoid causing premature shutdown before first error capture finishes\n            // it's hard to immediately tell case 1 from case 2 without doing some fancy/questionable domain stuff\n            // so let's instead just delay a bit before we proceed with our action here\n            // in case 1, we just wait a bit unnecessarily but ultimately do the same thing\n            // in case 2, the delay hopefully made us wait long enough for the capture to finish\n            // two potential nonideal outcomes:\n            //   nonideal case 1: capturing fails fast, we sit around for a few seconds unnecessarily before proceeding correctly by calling onFatalError\n            //   nonideal case 2: case 2 happens, 1st error is captured but slowly, timeout completes before capture and we treat second error as the sendErr of (nonexistent) failure from trying to capture first error\n            // note that after hitting this branch, we might catch more errors where (caughtSecondError && !calledFatalError)\n            //   we ignore them - they don't matter to us, we're just waiting for the second error timeout to finish\n            caughtSecondError = true;\n            setTimeout(() => {\n              if (!calledFatalError) {\n                // it was probably case 1, let's treat err as the sendErr and call onFatalError\n                calledFatalError = true;\n                onFatalError(firstError, error);\n              } else {\n                // it was probably case 2, our first error finished capturing while we waited, cool, do nothing\n              }\n            }, timeout); // capturing could take at least sendTimeout to fail, plus an arbitrary second for how long it takes to collect surrounding source etc\n          }\n        }\n      }\n    },\n    { _errorHandler: true },\n  );\n}\n"],"names":[],"mappings":";;;;AAgCA,MAAM,gBAAA,GAAmB,qBAAqB;;AAE9C;AACA;AACA;AACO,MAAM,8BAAA,GAAiC,iBAAiB,CAAC,CAAC,OAAO,GAAwC,EAAE,KAAK;AACvH,EAAE,MAAM,sBAAsB;AAC9B,IAAI,oCAAoC,EAAE,KAAK;AAC/C,IAAI,GAAG,OAAO;AACd,GAAG;;AAEH,EAAE,OAAO;AACT,IAAI,IAAI,EAAE,gBAAgB;AAC1B,IAAI,KAAK,CAAC,MAAM,EAAc;AAC9B,MAAM,MAAM,CAAC,OAAO,CAAC,EAAE,CAAC,mBAAmB,EAAE,gBAAgB,CAAC,MAAM,EAAE,mBAAmB,CAAC,CAAC;AAC3F,KAAK;AACL,GAAG;AACH,CAAC;;AAID;AACO,SAAS,gBAAgB,CAAC,MAAM,EAAc,OAAO,EAA4C;AACxG,EAAE,MAAM,OAAA,GAAU,IAAI;AACtB,EAAE,IAAI,gBAAgB,GAAY,KAAK;AACvC,EAAE,IAAI,iBAAiB,GAAY,KAAK;AACxC,EAAE,IAAI,gBAAgB,GAAY,KAAK;AACvC,EAAE,IAAI,UAAU;;AAEhB,EAAE,MAAM,aAAA,GAAgB,MAAM,CAAC,UAAU,EAAE;;AAE3C,EAAE,OAAO,MAAM,CAAC,MAAM;AACtB,IAAI,CAAC,KAAK,KAAkB;AAC5B,MAAM,IAAI,YAAY,GAAwB,iBAAiB;;AAE/D,MAAM,IAAI,OAAO,CAAC,YAAY,EAAE;AAChC,QAAQ,YAAA,GAAe,OAAO,CAAC,YAAY;AAC3C,aAAa,IAAI,aAAa,CAAC,YAAY,EAAE;AAC7C,QAAQ,YAAA,GAAe,aAAa,CAAC,YAAA;AACrC;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM,MAAM,0BAAA,GAA6B,CAAC,MAAM,CAAC,OAAO,CAAC,SAAS,CAAC,mBAAmB,CAAA,GAAuB,MAAM;AACnH,QAAQ,YAAY;AACpB;AACA,UAAU;AACV;AACA,YAAY,QAAQ,CAAC,IAAA,KAAS,8BAAA;AAC9B;AACA,YAAY,QAAQ,CAAC,GAAA,KAAQ,6BAAA;AAC7B;AACA,YAAY,CAAC,QAAA,GAA0B,kBAAkB;AACzD;AACA,SAAS;AACT,OAAO,CAAC,MAAM;;AAEd,MAAM,MAAM,gBAAA,GAAmB,0BAAA,KAA+B,CAAC;AAC/D,MAAM,MAAM,6BAAA,GAAgC,OAAO,CAAC,oCAAA,IAAwC,gBAAgB;;AAE5G,MAAM,IAAI,CAAC,gBAAgB,EAAE;AAC7B;AACA;AACA;AACA,QAAQ,UAAA,GAAa,KAAK;AAC1B,QAAQ,gBAAA,GAAmB,IAAI;;AAE/B,QAAQ,IAAI,SAAS,EAAC,KAAM,MAAM,EAAE;AACpC,UAAU,gBAAgB,CAAC,KAAK,EAAE;AAClC,YAAY,iBAAiB,EAAE,KAAK;AACpC,YAAY,cAAc,EAAE;AAC5B,cAAc,KAAK,EAAE,OAAO;AAC5B,aAAa;AACb,YAAY,SAAS,EAAE;AACvB,cAAc,OAAO,EAAE,KAAK;AAC5B,cAAc,IAAI,EAAE,qBAAqB;AACzC,aAAa;AACb,WAAW,CAAC;AACZ;;AAEA,QAAQ,IAAI,CAAC,gBAAA,IAAoB,6BAA6B,EAAE;AAChE,UAAU,gBAAA,GAAmB,IAAI;AACjC,UAAU,YAAY,CAAC,KAAK,CAAC;AAC7B;AACA,aAAa;AACb,QAAQ,IAAI,6BAA6B,EAAE;AAC3C,UAAU,IAAI,gBAAgB,EAAE;AAChC;AACA,YAAY,WAAA;AACZ,cAAc,KAAK,CAAC,IAAI;AACxB,gBAAgB,gGAAgG;AAChH,eAAe;AACf,YAAY,iBAAiB,CAAC,KAAK,CAAC;AACpC,iBAAiB,IAAI,CAAC,iBAAiB,EAAE;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,iBAAA,GAAoB,IAAI;AACpC,YAAY,UAAU,CAAC,MAAM;AAC7B,cAAc,IAAI,CAAC,gBAAgB,EAAE;AACrC;AACA,gBAAgB,gBAAA,GAAmB,IAAI;AACvC,gBAAgB,YAAY,CAAC,UAAU,EAAE,KAAK,CAAC;AAC/C;AAGA,aAAa,EAAE,OAAO,CAAC,CAAA;AACvB;AACA;AACA;AACA,KAAK;AACL,IAAI,EAAE,aAAa,EAAE,IAAA,EAAM;AAC3B,GAAG;AACH;;;;"}