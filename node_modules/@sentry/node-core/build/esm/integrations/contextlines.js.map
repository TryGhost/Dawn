{"version":3,"file":"contextlines.js","sources":["../../../src/integrations/contextlines.ts"],"sourcesContent":["import { createReadStream } from 'node:fs';\nimport { createInterface } from 'node:readline';\nimport type { Event, IntegrationFn, StackFrame } from '@sentry/core';\nimport { debug, defineIntegration, LRUMap, snipLine } from '@sentry/core';\nimport { DEBUG_BUILD } from '../debug-build';\n\nconst LRU_FILE_CONTENTS_CACHE = new LRUMap<string, Record<number, string>>(10);\nconst LRU_FILE_CONTENTS_FS_READ_FAILED = new LRUMap<string, 1>(20);\nconst DEFAULT_LINES_OF_CONTEXT = 7;\nconst INTEGRATION_NAME = 'ContextLines';\n// Determines the upper bound of lineno/colno that we will attempt to read. Large colno values are likely to be\n// minified code while large lineno values are likely to be bundled code.\n// Exported for testing purposes.\nexport const MAX_CONTEXTLINES_COLNO: number = 1000;\nexport const MAX_CONTEXTLINES_LINENO: number = 10000;\n\ninterface ContextLinesOptions {\n  /**\n   * Sets the number of context lines for each frame when loading a file.\n   * Defaults to 7.\n   *\n   * Set to 0 to disable loading and inclusion of source files.\n   **/\n  frameContextLines?: number;\n}\n\n/**\n * Exported for testing purposes.\n */\nexport function resetFileContentCache(): void {\n  LRU_FILE_CONTENTS_CACHE.clear();\n}\n\n/**\n * Get or init map value\n */\nfunction emplace<T extends LRUMap<K, V>, K extends string, V>(map: T, key: K, contents: V): V {\n  const value = map.get(key);\n\n  if (value === undefined) {\n    map.set(key, contents);\n    return contents;\n  }\n\n  return value;\n}\n\n/**\n * Determines if context lines should be skipped for a file.\n * - .min.(mjs|cjs|js) files are and not useful since they dont point to the original source\n * - node: prefixed modules are part of the runtime and cannot be resolved to a file\n * - data: skip json, wasm and inline js https://nodejs.org/api/esm.html#data-imports\n */\nfunction shouldSkipContextLinesForFile(path: string): boolean {\n  // Test the most common prefix and extension first. These are the ones we\n  // are most likely to see in user applications and are the ones we can break out of first.\n  if (path.startsWith('node:')) return true;\n  if (path.endsWith('.min.js')) return true;\n  if (path.endsWith('.min.cjs')) return true;\n  if (path.endsWith('.min.mjs')) return true;\n  if (path.startsWith('data:')) return true;\n  return false;\n}\n\n/**\n * Determines if we should skip contextlines based off the max lineno and colno values.\n */\nfunction shouldSkipContextLinesForFrame(frame: StackFrame): boolean {\n  if (frame.lineno !== undefined && frame.lineno > MAX_CONTEXTLINES_LINENO) return true;\n  if (frame.colno !== undefined && frame.colno > MAX_CONTEXTLINES_COLNO) return true;\n  return false;\n}\n/**\n * Checks if we have all the contents that we need in the cache.\n */\nfunction rangeExistsInContentCache(file: string, range: ReadlineRange): boolean {\n  const contents = LRU_FILE_CONTENTS_CACHE.get(file);\n  if (contents === undefined) return false;\n\n  for (let i = range[0]; i <= range[1]; i++) {\n    if (contents[i] === undefined) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n/**\n * Creates contiguous ranges of lines to read from a file. In the case where context lines overlap,\n * the ranges are merged to create a single range.\n */\nfunction makeLineReaderRanges(lines: number[], linecontext: number): ReadlineRange[] {\n  if (!lines.length) {\n    return [];\n  }\n\n  let i = 0;\n  const line = lines[0];\n\n  if (typeof line !== 'number') {\n    return [];\n  }\n\n  let current = makeContextRange(line, linecontext);\n  const out: ReadlineRange[] = [];\n  // eslint-disable-next-line no-constant-condition\n  while (true) {\n    if (i === lines.length - 1) {\n      out.push(current);\n      break;\n    }\n\n    // If the next line falls into the current range, extend the current range to lineno + linecontext.\n    const next = lines[i + 1];\n    if (typeof next !== 'number') {\n      break;\n    }\n    if (next <= current[1]) {\n      current[1] = next + linecontext;\n    } else {\n      out.push(current);\n      current = makeContextRange(next, linecontext);\n    }\n\n    i++;\n  }\n\n  return out;\n}\n\n/**\n * Extracts lines from a file and stores them in a cache.\n */\nfunction getContextLinesFromFile(path: string, ranges: ReadlineRange[], output: Record<number, string>): Promise<void> {\n  return new Promise((resolve, _reject) => {\n    // It is important *not* to have any async code between createInterface and the 'line' event listener\n    // as it will cause the 'line' event to\n    // be emitted before the listener is attached.\n    const stream = createReadStream(path);\n    const lineReaded = createInterface({\n      input: stream,\n    });\n\n    // We need to explicitly destroy the stream to prevent memory leaks,\n    // removing the listeners on the readline interface is not enough.\n    // See: https://github.com/nodejs/node/issues/9002 and https://github.com/getsentry/sentry-javascript/issues/14892\n    function destroyStreamAndResolve(): void {\n      stream.destroy();\n      resolve();\n    }\n\n    // Init at zero and increment at the start of the loop because lines are 1 indexed.\n    let lineNumber = 0;\n    let currentRangeIndex = 0;\n    const range = ranges[currentRangeIndex];\n    if (range === undefined) {\n      // We should never reach this point, but if we do, we should resolve the promise to prevent it from hanging.\n      destroyStreamAndResolve();\n      return;\n    }\n    let rangeStart = range[0];\n    let rangeEnd = range[1];\n\n    // We use this inside Promise.all, so we need to resolve the promise even if there is an error\n    // to prevent Promise.all from short circuiting the rest.\n    function onStreamError(e: Error): void {\n      // Mark file path as failed to read and prevent multiple read attempts.\n      LRU_FILE_CONTENTS_FS_READ_FAILED.set(path, 1);\n      DEBUG_BUILD && debug.error(`Failed to read file: ${path}. Error: ${e}`);\n      lineReaded.close();\n      lineReaded.removeAllListeners();\n      destroyStreamAndResolve();\n    }\n\n    // We need to handle the error event to prevent the process from crashing in < Node 16\n    // https://github.com/nodejs/node/pull/31603\n    stream.on('error', onStreamError);\n    lineReaded.on('error', onStreamError);\n    lineReaded.on('close', destroyStreamAndResolve);\n\n    lineReaded.on('line', line => {\n      lineNumber++;\n      if (lineNumber < rangeStart) return;\n\n      // !Warning: This mutates the cache by storing the snipped line into the cache.\n      output[lineNumber] = snipLine(line, 0);\n\n      if (lineNumber >= rangeEnd) {\n        if (currentRangeIndex === ranges.length - 1) {\n          // We need to close the file stream and remove listeners, else the reader will continue to run our listener;\n          lineReaded.close();\n          lineReaded.removeAllListeners();\n          return;\n        }\n        currentRangeIndex++;\n        const range = ranges[currentRangeIndex];\n        if (range === undefined) {\n          // This should never happen as it means we have a bug in the context.\n          lineReaded.close();\n          lineReaded.removeAllListeners();\n          return;\n        }\n        rangeStart = range[0];\n        rangeEnd = range[1];\n      }\n    });\n  });\n}\n\n/**\n * Adds surrounding (context) lines of the line that an exception occurred on to the event.\n * This is done by reading the file line by line and extracting the lines. The extracted lines are stored in\n * a cache to prevent multiple reads of the same file. Failures to read a file are similarly cached to prevent multiple\n * failing reads from happening.\n */\n/* eslint-disable complexity */\nasync function addSourceContext(event: Event, contextLines: number): Promise<Event> {\n  // keep a lookup map of which files we've already enqueued to read,\n  // so we don't enqueue the same file multiple times which would cause multiple i/o reads\n  const filesToLines: Record<string, number[]> = {};\n\n  if (contextLines > 0 && event.exception?.values) {\n    for (const exception of event.exception.values) {\n      if (!exception.stacktrace?.frames?.length) {\n        continue;\n      }\n\n      // Maps preserve insertion order, so we iterate in reverse, starting at the\n      // outermost frame and closer to where the exception has occurred (poor mans priority)\n      for (let i = exception.stacktrace.frames.length - 1; i >= 0; i--) {\n        const frame: StackFrame | undefined = exception.stacktrace.frames[i];\n        const filename = frame?.filename;\n\n        if (\n          !frame ||\n          typeof filename !== 'string' ||\n          typeof frame.lineno !== 'number' ||\n          shouldSkipContextLinesForFile(filename) ||\n          shouldSkipContextLinesForFrame(frame)\n        ) {\n          continue;\n        }\n\n        const filesToLinesOutput = filesToLines[filename];\n        if (!filesToLinesOutput) filesToLines[filename] = [];\n        // @ts-expect-error this is defined above\n        filesToLines[filename].push(frame.lineno);\n      }\n    }\n  }\n\n  const files = Object.keys(filesToLines);\n  if (files.length == 0) {\n    return event;\n  }\n\n  const readlinePromises: Promise<void>[] = [];\n  for (const file of files) {\n    // If we failed to read this before, dont try reading it again.\n    if (LRU_FILE_CONTENTS_FS_READ_FAILED.get(file)) {\n      continue;\n    }\n\n    const filesToLineRanges = filesToLines[file];\n    if (!filesToLineRanges) {\n      continue;\n    }\n\n    // Sort ranges so that they are sorted by line increasing order and match how the file is read.\n    filesToLineRanges.sort((a, b) => a - b);\n    // Check if the contents are already in the cache and if we can avoid reading the file again.\n    const ranges = makeLineReaderRanges(filesToLineRanges, contextLines);\n    if (ranges.every(r => rangeExistsInContentCache(file, r))) {\n      continue;\n    }\n\n    const cache = emplace(LRU_FILE_CONTENTS_CACHE, file, {});\n    readlinePromises.push(getContextLinesFromFile(file, ranges, cache));\n  }\n\n  // The promise rejections are caught in order to prevent them from short circuiting Promise.all\n  await Promise.all(readlinePromises).catch(() => {\n    DEBUG_BUILD && debug.log('Failed to read one or more source files and resolve context lines');\n  });\n\n  // Perform the same loop as above, but this time we can assume all files are in the cache\n  // and attempt to add source context to frames.\n  if (contextLines > 0 && event.exception?.values) {\n    for (const exception of event.exception.values) {\n      if (exception.stacktrace?.frames && exception.stacktrace.frames.length > 0) {\n        addSourceContextToFrames(exception.stacktrace.frames, contextLines, LRU_FILE_CONTENTS_CACHE);\n      }\n    }\n  }\n\n  return event;\n}\n/* eslint-enable complexity */\n\n/** Adds context lines to frames */\nfunction addSourceContextToFrames(\n  frames: StackFrame[],\n  contextLines: number,\n  cache: LRUMap<string, Record<number, string>>,\n): void {\n  for (const frame of frames) {\n    // Only add context if we have a filename and it hasn't already been added\n    if (frame.filename && frame.context_line === undefined && typeof frame.lineno === 'number') {\n      const contents = cache.get(frame.filename);\n      if (contents === undefined) {\n        continue;\n      }\n\n      addContextToFrame(frame.lineno, frame, contextLines, contents);\n    }\n  }\n}\n\n/**\n * Clears the context lines from a frame, used to reset a frame to its original state\n * if we fail to resolve all context lines for it.\n */\nfunction clearLineContext(frame: StackFrame): void {\n  delete frame.pre_context;\n  delete frame.context_line;\n  delete frame.post_context;\n}\n\n/**\n * Resolves context lines before and after the given line number and appends them to the frame;\n */\nexport function addContextToFrame(\n  lineno: number,\n  frame: StackFrame,\n  contextLines: number,\n  contents: Record<number, string> | undefined,\n): void {\n  // When there is no line number in the frame, attaching context is nonsensical and will even break grouping.\n  // We already check for lineno before calling this, but since StackFrame lineno ism optional, we check it again.\n  if (frame.lineno === undefined || contents === undefined) {\n    DEBUG_BUILD && debug.error('Cannot resolve context for frame with no lineno or file contents');\n    return;\n  }\n\n  frame.pre_context = [];\n  for (let i = makeRangeStart(lineno, contextLines); i < lineno; i++) {\n    // We always expect the start context as line numbers cannot be negative. If we dont find a line, then\n    // something went wrong somewhere. Clear the context and return without adding any linecontext.\n    const line = contents[i];\n    if (line === undefined) {\n      clearLineContext(frame);\n      DEBUG_BUILD && debug.error(`Could not find line ${i} in file ${frame.filename}`);\n      return;\n    }\n\n    frame.pre_context.push(line);\n  }\n\n  // We should always have the context line. If we dont, something went wrong, so we clear the context and return\n  // without adding any linecontext.\n  if (contents[lineno] === undefined) {\n    clearLineContext(frame);\n    DEBUG_BUILD && debug.error(`Could not find line ${lineno} in file ${frame.filename}`);\n    return;\n  }\n\n  frame.context_line = contents[lineno];\n\n  const end = makeRangeEnd(lineno, contextLines);\n  frame.post_context = [];\n  for (let i = lineno + 1; i <= end; i++) {\n    // Since we dont track when the file ends, we cant clear the context if we dont find a line as it could\n    // just be that we reached the end of the file.\n    const line = contents[i];\n    if (line === undefined) {\n      break;\n    }\n    frame.post_context.push(line);\n  }\n}\n\n// Helper functions for generating line context ranges. They take a line number and the number of lines of context to\n// include before and after the line and generate an inclusive range of indices.\ntype ReadlineRange = [start: number, end: number];\n// Compute inclusive end context range\nfunction makeRangeStart(line: number, linecontext: number): number {\n  return Math.max(1, line - linecontext);\n}\n// Compute inclusive start context range\nfunction makeRangeEnd(line: number, linecontext: number): number {\n  return line + linecontext;\n}\n// Determine start and end indices for context range (inclusive);\nfunction makeContextRange(line: number, linecontext: number): [start: number, end: number] {\n  return [makeRangeStart(line, linecontext), makeRangeEnd(line, linecontext)];\n}\n\n/** Exported only for tests, as a type-safe variant. */\nexport const _contextLinesIntegration = ((options: ContextLinesOptions = {}) => {\n  const contextLines = options.frameContextLines !== undefined ? options.frameContextLines : DEFAULT_LINES_OF_CONTEXT;\n\n  return {\n    name: INTEGRATION_NAME,\n    processEvent(event) {\n      return addSourceContext(event, contextLines);\n    },\n  };\n}) satisfies IntegrationFn;\n\n/**\n * Capture the lines before and after the frame's context.\n */\nexport const contextLinesIntegration = defineIntegration(_contextLinesIntegration);\n"],"names":[],"mappings":"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"}