{"version":3,"file":"node-schedule.js","sources":["../../../src/cron/node-schedule.ts"],"sourcesContent":["import { withMonitor } from '@sentry/core';\nimport { replaceCronNames } from './common';\n\nexport interface NodeSchedule {\n  scheduleJob(\n    nameOrExpression: string | Date | object,\n    expressionOrCallback: string | Date | object | (() => void),\n    callback?: () => void,\n  ): unknown;\n}\n\n/**\n * Instruments the `node-schedule` library to send a check-in event to Sentry for each job execution.\n *\n * ```ts\n * import * as Sentry from '@sentry/node';\n * import * as schedule from 'node-schedule';\n *\n * const scheduleWithCheckIn = Sentry.cron.instrumentNodeSchedule(schedule);\n *\n * const job = scheduleWithCheckIn.scheduleJob('my-cron-job', '* * * * *', () => {\n *  console.log('You will see this message every minute');\n * });\n * ```\n */\nexport function instrumentNodeSchedule<T>(lib: T & NodeSchedule): T {\n  return new Proxy(lib, {\n    get(target, prop: keyof NodeSchedule) {\n      if (prop === 'scheduleJob') {\n        // eslint-disable-next-line @typescript-eslint/unbound-method\n        return new Proxy(target.scheduleJob, {\n          apply(target, thisArg, argArray: Parameters<NodeSchedule['scheduleJob']>) {\n            const [nameOrExpression, expressionOrCallback, callback] = argArray;\n\n            if (\n              typeof nameOrExpression !== 'string' ||\n              typeof expressionOrCallback !== 'string' ||\n              typeof callback !== 'function'\n            ) {\n              throw new Error(\n                \"Automatic instrumentation of 'node-schedule' requires the first parameter of 'scheduleJob' to be a job name string and the second parameter to be a crontab string\",\n              );\n            }\n\n            const monitorSlug = nameOrExpression;\n            const expression = expressionOrCallback;\n\n            async function monitoredCallback(): Promise<void> {\n              return withMonitor(\n                monitorSlug,\n                async () => {\n                  await callback?.();\n                },\n                {\n                  schedule: { type: 'crontab', value: replaceCronNames(expression) },\n                },\n              );\n            }\n\n            return target.apply(thisArg, [monitorSlug, expression, monitoredCallback]);\n          },\n        });\n      }\n\n      return target[prop];\n    },\n  });\n}\n"],"names":[],"mappings":";;;AAWA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAAS,sBAAsB,CAAI,GAAG,EAAuB;AACpE,EAAE,OAAO,IAAI,KAAK,CAAC,GAAG,EAAE;AACxB,IAAI,GAAG,CAAC,MAAM,EAAE,IAAI,EAAsB;AAC1C,MAAM,IAAI,IAAA,KAAS,aAAa,EAAE;AAClC;AACA,QAAQ,OAAO,IAAI,KAAK,CAAC,MAAM,CAAC,WAAW,EAAE;AAC7C,UAAU,KAAK,CAAC,MAAM,EAAE,OAAO,EAAE,QAAQ,EAA2C;AACpF,YAAY,MAAM,CAAC,gBAAgB,EAAE,oBAAoB,EAAE,QAAQ,CAAA,GAAI,QAAQ;;AAE/E,YAAY;AACZ,cAAc,OAAO,gBAAA,KAAqB,QAAA;AAC1C,cAAc,OAAO,oBAAA,KAAyB,QAAA;AAC9C,cAAc,OAAO,aAAa;AAClC,cAAc;AACd,cAAc,MAAM,IAAI,KAAK;AAC7B,gBAAgB,oKAAoK;AACpL,eAAe;AACf;;AAEA,YAAY,MAAM,WAAA,GAAc,gBAAgB;AAChD,YAAY,MAAM,UAAA,GAAa,oBAAoB;;AAEnD,YAAY,eAAe,iBAAiB,GAAkB;AAC9D,cAAc,OAAO,WAAW;AAChC,gBAAgB,WAAW;AAC3B,gBAAgB,YAAY;AAC5B,kBAAkB,MAAM,QAAQ,IAAI;AACpC,iBAAiB;AACjB,gBAAgB;AAChB,kBAAkB,QAAQ,EAAE,EAAE,IAAI,EAAE,SAAS,EAAE,KAAK,EAAE,gBAAgB,CAAC,UAAU,GAAG;AACpF,iBAAiB;AACjB,eAAe;AACf;;AAEA,YAAY,OAAO,MAAM,CAAC,KAAK,CAAC,OAAO,EAAE,CAAC,WAAW,EAAE,UAAU,EAAE,iBAAiB,CAAC,CAAC;AACtF,WAAW;AACX,SAAS,CAAC;AACV;;AAEA,MAAM,OAAO,MAAM,CAAC,IAAI,CAAC;AACzB,KAAK;AACL,GAAG,CAAC;AACJ;;;;"}